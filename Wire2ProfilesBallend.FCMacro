
__title__ = "Create gcode for processing sweeped wire by BallEnd"
__doc__ = ""
__url__ = "https://forum.freecad.org/viewtopic.php?t=94642"

import FreeCAD
import FreeCADGui
import Part
import Path
import PathScripts.PathUtils as PathUtils

import copy
import math
import numpy
import time

"""
1. Create Job
2. Add BallEnd tool
3. Create Profile for contour
4. Select Profile operation and wire (edges of sweeped shape along profile)
   Disable Refine in solid object if some edges was hidden
5. Execute macro
   Check Report view if needed
"""


step = 2.0               # Distance between points on wire
removeStartMoves = 3     # Remove n commands from the begin of each step (default 3)
removeEndMoves = 2       # Remove n commands from the end of each step (default 2)
repeatLastStep = False   # Repeat last step (default False; set True for "helix" path)


def rndVec(vector, prec=1):
    x = round(vector.x, prec)
    y = round(vector.y, prec)
    z = round(vector.z, prec)
    return FreeCAD.Vector(x, y, z)

def normalToEdgeAt(edge, point, plane, zpos = False):
    """
    https://forum.freecad.org/viewtopic.php?p=842307#p842307
    find normal to edge at point. If undefined because curvature vanishes
    return normal in plane
    if zpos=True return normal with a positive z-component
    """
    curve = edge.Curve
    s = curve.parameter(point)
    if abs(curve.curvature(s)) > 1e-7:
        normal = curve.normal(s)
    else:
        normal = plane.normal(0,0).cross(curve.tangent(s)[0])
    if normal.z < 0 and zpos:
        normal = -normal

    return normal

def searchLimitsPoints(wire):
    # search top - point with max Z
    # and bottom - point with min Z
    top = None
    bottom = None
    for vertex in wire.Vertexes:
        if top is None or vertex.Point.z > top.z:
            top = vertex.Point
        if bottom is None or vertex.Point.z < bottom.z:
            bottom = vertex.Point
    return top, bottom

def searchStartEnd(point1, point2, wire):
    # point on a wire is startPoint
    # another point is endPoint
    for vertex in wire.Vertexes:
        if Path.Geom.pointsCoincide(vertex.Point, point1):
            return point1, point2
            break
        elif Path.Geom.pointsCoincide(vertex.Point, point2):
            return point2, point1
            break
    else:
        print("  Error: Wire not start from base operation")

def isWireUpInStart(point, wire):
    for vertex in wire.Vertexes:
        if not Path.Geom.isRoughly(vertex.Point.z, point.z):
            if vertex.Point.z > point.z:
                return True
            elif vertex.Point.z <point.z:
                return False
    return False


print()
print("--- Macro to create gcode for processing sweeped wire by BallEnd ---")

timeStart = time.monotonic()

sel = FreeCADGui.Selection.getSelectionEx()
if not sel:
    print("  Error: Base operation and profile not selected")

else:
    selOps = [s.Object for s in sel if "Profile" in s.Object.Name]
    if not selOps:
        baseOp = None
        print("  Error: Profile operation not selected")
    elif selOps[0].Path.Length:
        baseOp = selOps[0]
    else:
        baseOp = None
        print("  Error: Profile do not contain Path")

    shapes = [s for s in sel if "Part" in s.Object.TypeId]
    wireProfile = None
    if shapes:
        shape = shapes[0]
        base = shape.Object
        subNames = shape.SubElementNames
        edges = [base.Shape.getElement(sub).copy() for sub in subNames if sub.startswith("Edge")]
        if edges:
            wireProfile = Part.Wire(Part.__sortEdges__(edges))
            wireProfilePlane = wireProfile.findPlane()
        else:
            print("  Error: Selection do not contain edges")

    if not wireProfile:
        print("  Error: Sweeped wire not selected")


    if baseOp and wireProfile:
        pathEdges = []
        for base, subs in baseOp.Base:
            for feature in subs:
                sub = base.Shape.getElement(feature)
                if type(sub) is Part.Edge:
                    pathEdges.append(sub)
        wirePath = Part.Wire(Part.__sortEdges__(pathEdges))
        wirePathCenter = wirePath.BoundBox.Center

        pointTop, pointBottom = searchLimitsPoints(wireProfile)
        print(f"  top={rndVec(pointTop)}  bottom={rndVec(pointBottom)}")

        p1, p2 = wireProfile.Vertexes[0].Point, wireProfile.Vertexes[-1].Point
        pointProfileStart, pointProfileEnd = searchStartEnd(p1, p2, wirePath)
        print(f"  wirePathCenter={rndVec(wirePathCenter,1)}")
        print(f"  pointProfileStart={rndVec(pointProfileStart)}  pointProfileEnd={rndVec(pointProfileEnd)}")

        p1, p2 = copy.copy(pointProfileStart), copy.copy(pointProfileEnd)
        p1.z, p2.z = 0, 0
        if wirePathCenter.distanceToPoint(p1) < wirePathCenter.distanceToPoint(p2):
            dirFromCenter = True
        else:
            dirFromCenter = False

        wireUpInStart = isWireUpInStart(pointProfileStart, wireProfile)
        if wireUpInStart and dirFromCenter:
            signD = -1
        else:
            signD = 1
        print(f"  dirFromCenter={dirFromCenter}  wireUpInStart={wireUpInStart}  signD={signD}")

        # Create copy of Profile operation
        tempOp = FreeCAD.ActiveDocument.copyObject(baseOp)
        job = PathUtils.findParentJob(baseOp)
        job.Proxy.addOperation(tempOp)

        tempOp.setExpression("FinalDepth", None)
        tempOp.setExpression("StartDepth", None)
        tempOp.setExpression("StepDown", None)
        tempOp.UseComp = False
        tempOp.Side = "Outside"
        tempOp.StartDepth = pointTop.z
        tempOp.OffsetExtra = 0

        tool = tempOp.ToolController.Tool
        toolDiam = tool.Diameter.Value
        toolRadius = toolDiam / 2
        tempOp.StepDown = pointTop.z - pointBottom.z + toolRadius + 0.1

        pVert = copy.copy(pointProfileStart)
        commandlist = []
        counter = 0

        p1 = wireProfile.Edges[0].Vertexes[0].Point
        p2 = wireProfile.Edges[0].Vertexes[-1].Point
        if Path.Geom.pointsCoincide(p1, pointProfileStart) or Path.Geom.pointsCoincide(p2, pointProfileStart):
            edgesOrder = wireProfile.Edges
        else:
            edgesOrder = reversed(wireProfile.Edges)

        lastPoint = pointProfileStart
        xSign = None
        ySign = None
        for edge in edgesOrder:
            edgeRadius = getattr(sub.Curve, "Radius", None)
            if edgeRadius and edgeRadius < toolRadius:
                print("  Warning: One of the edge has radius less than tool radius")

            points = edge.discretize(Distance = step)
            if not Path.Geom.pointsCoincide(lastPoint, points[0]):
                points = points[::-1]
            lastPoint = points[-1]

            normals = [normalToEdgeAt(edge, point, wireProfilePlane, True) for point in points]

            for i, normal in enumerate(normals):
                if counter and i == 0:
                    # End point previous edge coincide with start point next edge
                    # Skip repeat
                    continue
                prec = 5
                xS = numpy.sign(round(normal.x, prec))
                yS = numpy.sign(round(normal.y, prec))
                # xS = numpy.sign(normal.x)
                # yS = numpy.sign(normal.y)
                if (
                    (xSign is not None and xS and xSign != xS)
                or  (ySign is not None and yS and ySign != yS)
                ):
                    print(f"{i}  Change sign {xSign}=!{xS}  {ySign}=!{yS}")
                    signD *= -1
                    pass
                if xS:
                    xSign = xS
                if yS:
                    ySign = yS

                pVert.z = points[i].z
                signH = 1 if dirFromCenter else -1
                offsetExtra = points[i].distanceToPoint(pVert) * signH + math.hypot(normal.x, normal.y) * toolRadius * signD
                finalDepth = points[i].z + abs(normal.z) * toolRadius - toolRadius

                # print(f"{i}  offset={round(offsetExtra,1)}  depth={round(finalDepth,1)}  normal={rndVec(normal,3)}")

                # Set currentDepth and offsetExtra to Profile
                tempOp.OffsetExtra = offsetExtra
                tempOp.FinalDepth = finalDepth
                tempOp.recompute()

                counter += 1
                cmd = Path.Command(f"(WireGcodeBallEnd {counter} Depth={round(finalDepth,2)} Offset={round(offsetExtra,2)})")
                commandlist.append(cmd)
                if counter == 1:
                    commandlist.extend(tempOp.Path.Commands[2:-removeEndMoves])
                else:
                    commandlist.extend(tempOp.Path.Commands[2+removeStartMoves:-removeEndMoves])

        if repeatLastStep:
            # Repeat last Profile
            commandlist.extend(tempOp.Path.Commands[2+removeStartMoves:])
        elif removeEndMoves > 0:
            # Return last move to clearance height
            commandlist.extend(tempOp.Path.Commands[-removeEndMoves:])

        # Delete copy of Profile
        FreeCAD.ActiveDocument.removeObject(tempOp.Name)

        res = Path.Op.Gui.Custom.Command.res
        WireGcode = Path.Op.Custom.Create("WireGcodeBallEnd")
        WireGcode.ViewObject.Proxy = Path.Op.Gui.Custom.PathOpGui.ViewProvider(WireGcode.ViewObject, res)
        WireGcode.Gcode = [cmd.toGCode() for cmd in commandlist]
        WireGcode.ViewObject.Visibility = True
        WireGcode.ViewObject.Proxy.deleteOnReject = False
        WireGcode.recompute()

        timeComp = round(time.monotonic()-timeStart, 1)
        print(f"  Amount profiles: {counter}  Step: {step} mm  Tool diameter: {toolDiam} mm")
        print(f"  Time computation: {timeComp} sec")
